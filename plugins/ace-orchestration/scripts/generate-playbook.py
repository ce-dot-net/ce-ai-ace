#!/usr/bin/env python3
"""
Generate CLAUDE.md playbook from learned patterns

Implements ACE paper's bulletized structure (arxiv:2510.04618):
- DOMAIN TAXONOMY (auto-discovered from patterns)
- STRATEGIES AND HARD RULES (high-confidence patterns ‚â•70%)
- USEFUL CODE SNIPPETS AND TEMPLATES (code-focused patterns)
- TROUBLESHOOTING AND PITFALLS (anti-patterns and failures)

ACE Phase 3: Uses delta updates instead of full rewrites to prevent context collapse.
Bulletized format: [bullet-id] helpful=X harmful=Y :: content

Reads patterns from SQLite database and generates comprehensive
markdown playbook organized by ACE sections and confidence levels.
"""

import sqlite3
import sys
import json
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional

PROJECT_ROOT = Path.cwd()
DB_PATH = PROJECT_ROOT / '.ace-memory' / 'patterns.db'
PLAYBOOK_PATH = PROJECT_ROOT / 'CLAUDE.md'
TAXONOMY_PATH = PROJECT_ROOT / '.ace-memory' / 'domain_taxonomy.json'

CONFIDENCE_HIGH = 0.7  # 70%
CONFIDENCE_MEDIUM = 0.3   # 30%

def get_patterns_with_insights() -> List[Dict]:
    """Get all patterns with their insights from database."""
    if not DB_PATH.exists():
        return []

    conn = sqlite3.connect(str(DB_PATH))
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    # Get patterns
    cursor.execute('SELECT * FROM patterns ORDER BY confidence DESC, observations DESC')
    patterns = [dict(row) for row in cursor.fetchall()]

    # Get insights for each pattern
    for pattern in patterns:
        cursor.execute('''
            SELECT * FROM insights
            WHERE pattern_id = ?
            ORDER BY timestamp DESC
            LIMIT 5
        ''', (pattern['id'],))
        pattern['insights'] = [dict(row) for row in cursor.fetchall()]

    conn.close()
    return patterns


def load_domain_taxonomy() -> Optional[Dict]:
    """Load discovered domain taxonomy from JSON file."""
    if not TAXONOMY_PATH.exists():
        return None

    try:
        with open(TAXONOMY_PATH, 'r') as f:
            taxonomy = json.load(f)
        return taxonomy
    except Exception as e:
        print(f"‚ö†Ô∏è  Failed to load domain taxonomy: {e}", file=sys.stderr)
        return None


def generate_playbook():
    """Generate CLAUDE.md playbook with ACE structure."""
    patterns = get_patterns_with_insights()

    if not patterns:
        # No patterns yet, create minimal playbook
        content = f"""# ACE Playbook

*Auto-generated by ACE (Agentic Context Engineering)*
*Last updated: {datetime.now().isoformat()}*

**No patterns learned yet.** Patterns will be automatically detected and analyzed as you code.

## üìä Statistics
- Total patterns: 0
- Observations: 0

## üöÄ Getting Started

The ACE plugin will automatically:
1. Detect patterns in your code (Python, JavaScript, TypeScript)
2. Analyze their effectiveness based on test results
3. Build this playbook with actionable insights

Start coding, and watch this playbook evolve!

## üí° Commands

- `/ace-status` - View learning statistics
- `/ace-patterns` - List all learned patterns
- `/ace-force-reflect` - Manually trigger reflection on a file
- `/ace-clear` - Reset pattern database
"""
        PLAYBOOK_PATH.write_text(content)
        return

    # Calculate stats
    total_observations = sum(p['observations'] for p in patterns)
    total_successes = sum(p['successes'] for p in patterns)
    success_rate = (total_successes / total_observations * 100) if total_observations > 0 else 0

    # Group patterns by type and confidence
    high = [p for p in patterns if p['confidence'] >= CONFIDENCE_HIGH]
    medium = [p for p in patterns if CONFIDENCE_MEDIUM <= p['confidence'] < CONFIDENCE_HIGH]
    low = [p for p in patterns if p['confidence'] < CONFIDENCE_MEDIUM]
    anti_patterns = [p for p in patterns if p['type'] == 'harmful' and p['confidence'] >= CONFIDENCE_HIGH]

    # Load domain taxonomy
    taxonomy = load_domain_taxonomy()

    # Count discovered domains
    domains_discovered = 0
    if taxonomy:
        domains_discovered = (
            len(taxonomy.get('concrete', {})) +
            len(taxonomy.get('abstract', {})) +
            len(taxonomy.get('principles', {}))
        )

    # Generate markdown with ACE sections
    content = f"""# ACE Playbook

*Auto-generated by ACE (Agentic Context Engineering)*
*Last updated: {datetime.now().isoformat()}*
*Total patterns: {len(patterns)}*

## üìä Statistics

- **Total Observations**: {total_observations}
- **Success Rate**: {success_rate:.1f}%
- **High Confidence Patterns**: {len(high)} (‚â•70%)
- **Medium Confidence Patterns**: {len(medium)} (30-70%)
- **Low Confidence Patterns**: {len(low)} (<30%)
- **Anti-Patterns Identified**: {len(anti_patterns)}
- **Domains Discovered**: {domains_discovered}

---

"""

    # SECTION 0: DOMAIN TAXONOMY (if discovered)
    if taxonomy and domains_discovered > 0:
        content += "## üó∫Ô∏è DOMAIN TAXONOMY\n\n"
        content += "*Auto-discovered domain structure organized from concrete to abstract levels.*\n\n"

        # Concrete Domains
        concrete = taxonomy.get('concrete', {})
        if concrete:
            content += "### üìç Concrete Domains\n\n"
            content += "*File-location and library-specific domains discovered from actual code patterns.*\n\n"

            for domain_id, domain_info in sorted(concrete.items(),
                                                   key=lambda x: x[1].get('confidence', 0),
                                                   reverse=True):
                confidence = domain_info.get('confidence', 0)
                description = domain_info.get('description', 'No description')
                evidence = domain_info.get('evidence', [])
                patterns_list = domain_info.get('patterns', [])

                content += f"**{domain_id}** (confidence: {confidence:.1%})\n"
                content += f"- *Description*: {description}\n"
                if evidence:
                    content += f"- *Evidence*: {', '.join(evidence[:3])}"
                    if len(evidence) > 3:
                        content += f" (+{len(evidence)-3} more)"
                    content += "\n"
                if patterns_list:
                    content += f"- *Patterns*: {len(patterns_list)} patterns in this domain\n"
                content += "\n"

        # Abstract Patterns
        abstract = taxonomy.get('abstract', {})
        if abstract:
            content += "### üîÑ Abstract Patterns\n\n"
            content += "*Architectural patterns and design approaches that recur across concrete domains.*\n\n"

            for pattern_id, pattern_info in sorted(abstract.items(),
                                                     key=lambda x: x[1].get('confidence', 0),
                                                     reverse=True):
                confidence = pattern_info.get('confidence', 0)
                description = pattern_info.get('description', 'No description')
                instances = pattern_info.get('instances', [])

                content += f"**{pattern_id}** (confidence: {confidence:.1%})\n"
                content += f"- *Description*: {description}\n"
                if instances:
                    content += f"- *Applied in*: {', '.join(instances)}\n"
                content += "\n"

        # Principles
        principles = taxonomy.get('principles', {})
        if principles:
            content += "### üéØ Principles\n\n"
            content += "*General coding principles and best practices identified across all patterns.*\n\n"

            for principle_id, principle_info in sorted(principles.items(),
                                                        key=lambda x: x[1].get('confidence', 0),
                                                        reverse=True):
                confidence = principle_info.get('confidence', 0)
                description = principle_info.get('description', 'No description')
                applied_in = principle_info.get('applied_in', [])

                content += f"**{principle_id}** (confidence: {confidence:.1%})\n"
                content += f"- *Description*: {description}\n"
                if applied_in:
                    content += f"- *Applied through*: {', '.join(applied_in)}\n"
                content += "\n"

        # Metadata
        metadata = taxonomy.get('metadata', {})
        if metadata:
            total_analyzed = metadata.get('total_patterns_analyzed', 0)
            method = metadata.get('discovery_method', 'unknown')
            discovered_at = metadata.get('discovered_at', 'unknown')

            content += f"*Taxonomy discovered from {total_analyzed} patterns using {method}*\n"
            content += f"*Last discovery: {discovered_at}*\n\n"

        content += "---\n\n"

    # SECTION 1: STRATEGIES AND HARD RULES
    if high:
        content += "## üéØ STRATEGIES AND HARD RULES\n\n"
        content += "*High-confidence patterns (‚â•70%) proven effective through multiple observations.*\n\n"

        for pattern in high:
            bullet_id = pattern.get('bullet_id', f"[{pattern['id']}]")
            helpful = pattern.get('helpful_count', 0)
            harmful = pattern.get('harmful_count', 0)

            content += f"{bullet_id} helpful={helpful} harmful={harmful} :: **{pattern['name']}**  \n"
            content += f"*Domain: {pattern['domain']} | Language: {pattern['language']} | Confidence: {pattern['confidence']*100:.1f}% ({pattern['successes']}/{pattern['observations']})*\n\n"
            content += f"{pattern['description']}\n\n"

            if pattern['insights']:
                latest = pattern['insights'][0]
                content += f"üí° **Latest Insight**: {latest['insight']}\n\n"
                content += f"üìã **Recommendation**: {latest['recommendation']}\n\n"

            content += "---\n\n"

    # SECTION 2: USEFUL CODE SNIPPETS AND TEMPLATES
    code_patterns = [p for p in high if 'code' in p['description'].lower() or 'snippet' in p['description'].lower()]
    if code_patterns:
        content += "## üíª USEFUL CODE SNIPPETS AND TEMPLATES\n\n"
        content += "*Ready-to-use code patterns and templates.*\n\n"

        for pattern in code_patterns:
            bullet_id = pattern.get('bullet_id', f"[{pattern['id']}]")
            content += f"{bullet_id} :: **{pattern['name']}**\n\n"
            content += f"```{pattern['language']}\n# {pattern['description']}\n```\n\n"
            content += "---\n\n"

    # SECTION 3: TROUBLESHOOTING AND PITFALLS
    if anti_patterns or low:
        content += "## üö´ TROUBLESHOOTING AND PITFALLS\n\n"
        content += "*Common mistakes and anti-patterns to avoid.*\n\n"

        for pattern in anti_patterns:
            bullet_id = pattern.get('bullet_id', f"[{pattern['id']}]")
            helpful = pattern.get('helpful_count', 0)
            harmful = pattern.get('harmful_count', 0)

            content += f"{bullet_id} helpful={helpful} harmful={harmful} :: ‚ùå **{pattern['name']}**  \n"
            content += f"*Confidence: {pattern['confidence']*100:.1f}% harmful*\n\n"
            content += f"**Why to Avoid**: {pattern['description']}\n\n"

            if pattern['insights']:
                latest = pattern['insights'][0]
                content += f"‚ö†Ô∏è **Warning**: {latest['insight']}\n\n"

            content += "---\n\n"

    # SECTION 4: MEDIUM-CONFIDENCE PATTERNS (Needs Validation)
    if medium:
        content += "## ‚öôÔ∏è PATTERNS UNDER VALIDATION (30-70% Confidence)\n\n"
        content += "*These show promise but need more observations. Verify before relying on them.*\n\n"

        for pattern in medium:
            bullet_id = pattern.get('bullet_id', f"[{pattern['id']}]")
            content += f"{bullet_id} :: **{pattern['name']}** ({pattern['confidence']*100:.1f}%, {pattern['observations']} obs)  \n"
            content += f"{pattern['description']}\n\n"

    # SECTION 5: LOW-CONFIDENCE PATTERNS (May be pruned)
    if low:
        content += "## üîç LOW-CONFIDENCE PATTERNS (<30%)\n\n"
        content += "*May be pruned if they don't improve after more observations.*\n\n"

        for pattern in low:
            bullet_id = pattern.get('bullet_id', f"[{pattern['id']}]")
            content += f"- {bullet_id} **{pattern['name']}** ({pattern['confidence']*100:.0f}%, {pattern['observations']} obs)\n"

        content += "\n---\n\n"

    # Footer
    content += """## üí° ACE Commands

- `/ace-status` - View detailed learning statistics
- `/ace-patterns [domain] [min-confidence]` - List patterns with filtering
- `/ace-force-reflect [file]` - Manually trigger reflection on a file
- `/ace-clear --confirm` - Reset pattern database

---

*This playbook evolves automatically as you code. Patterns are learned from your coding style and validated through test results.*

*Based on research: [Agentic Context Engineering](https://arxiv.org/abs/2510.04618) by Stanford/SambaNova/UC Berkeley*
"""

    # Check if we need full rewrite (for structural changes like domain taxonomy)
    needs_full_rewrite = False
    if PLAYBOOK_PATH.exists():
        existing_content = PLAYBOOK_PATH.read_text()
        # Check if domain taxonomy section exists in current playbook
        has_taxonomy_section = "DOMAIN TAXONOMY" in existing_content
        should_have_taxonomy = taxonomy and domains_discovered > 0

        # Need full rewrite if taxonomy status changed
        if has_taxonomy_section != should_have_taxonomy:
            needs_full_rewrite = True
            print("üîÑ Domain taxonomy section changed - full rewrite needed", file=sys.stderr)

    # Apply delta update (ACE Phase 3: incremental updates only)
    # BUT use full rewrite for structural changes
    if needs_full_rewrite:
        PLAYBOOK_PATH.write_text(content)
        print(f"‚úÖ Playbook updated (full rewrite): {len(patterns)} patterns", file=sys.stderr)
    else:
        try:
            # Import delta updater
            sys.path.insert(0, str(Path(__file__).parent))
            from playbook_delta_updater import update_playbook_with_delta

            # Use delta update instead of full rewrite
            success = update_playbook_with_delta(content)

            if success:
                print(f"‚úÖ Playbook updated (delta): {len(patterns)} patterns", file=sys.stderr)
            else:
                # Fallback to full write only on first run
                if not PLAYBOOK_PATH.exists():
                    PLAYBOOK_PATH.write_text(content)
                    print(f"‚úÖ Playbook created: {len(patterns)} patterns", file=sys.stderr)
                else:
                    print(f"‚ÑπÔ∏è  No changes to apply", file=sys.stderr)

        except Exception as e:
            # Fallback to full write on error (safety)
            print(f"‚ö†Ô∏è  Delta update failed ({e}), falling back to full write", file=sys.stderr)
            PLAYBOOK_PATH.write_text(content)
            print(f"‚úÖ Playbook updated: {len(patterns)} patterns", file=sys.stderr)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Generate ACE playbooks')
    parser.add_argument('--format',
                       choices=['legacy', 'speckit', 'both'],
                       default='both',
                       help='Playbook format to generate (default: both)')

    args = parser.parse_args()

    try:
        # Generate legacy CLAUDE.md
        if args.format in ['legacy', 'both']:
            generate_playbook()

        # Generate spec-kit structure
        if args.format in ['speckit', 'both']:
            try:
                import importlib.util

                # Import generate-speckit-playbook.py (with hyphen)
                spec = importlib.util.spec_from_file_location(
                    "generate_speckit_playbook",
                    Path(__file__).parent / "generate-speckit-playbook.py"
                )
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                module.generate_speckit_playbooks()
            except Exception as e:
                print(f"‚ö†Ô∏è  spec-kit generation failed: {e}", file=sys.stderr)
                if args.format == 'speckit':
                    # If only speckit requested, this is an error
                    raise

        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Failed to generate playbook: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc(file=sys.stderr)
        sys.exit(1)
